import Highlight, { defaultProps } from 'prism-react-renderer';
import { jsx, Themed } from 'theme-ui';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const aliases = {
  js: 'javascript',
  sh: 'bash'
};

const isInRange = (start, end, num) => {
  if (num >= start && num <= end) {
    return true;
  }

  return false;
};

const checkRanges = (range, num) => {
  for (let i = 0; i < range.length; i += 2) {
    if (isInRange(range[i], range[i + 1], num)) {
      return true;
    }
  }

  return false;
};

function ThemeUIPrism({
  children,
  className: outerClassName,
  ...props
}) {
  const [language] = outerClassName.replace(/language-/, '').split(' ');
  const lang = aliases[language] || language;
  let startEndRangesToHighlight = [];
  let countHighlightCommentsRemoved = 0;

  const findStartAndEndHighlights = tokens => {
    const tokensWithoutHighlightComments = tokens.filter((item, index) => {
      const removeLine = item.map(({
        content
      }) => {
        if (content.trim() === '// highlight-start') {
          /**
           * Track highlighted lines, including countHighlightCommentsRemoved 
           * so we can keep track of multiple highlight-start and highlight-end blocks. 
           * */
          startEndRangesToHighlight.push(index - countHighlightCommentsRemoved);
          countHighlightCommentsRemoved += 1;
          return true;
        }

        if (content.trim() === '// highlight-end') {
          /**
           * Subtract by (countHighlightCommentsRemoved + 1) to account for 
           * the current highlight-end block being removed.
           * */
          startEndRangesToHighlight.push(index - (countHighlightCommentsRemoved + 1));
          countHighlightCommentsRemoved += 1;
          return true;
        }
      }).filter(Boolean)[0];

      if (!removeLine) {
        return item;
      }
    });
    return tokensWithoutHighlightComments;
  };

  const isStartEndHighlighted = index => {
    return checkRanges(startEndRangesToHighlight, index);
  };

  const isInlineHighlighted = line => {
    const regex = new RegExp('// highlight-line$');

    for (let token of line) {
      if (regex.test(token.content)) {
        token.content = token.content.replace(regex, ''); // remove the highlight-line comment now that we've acted on it

        return true;
      }
    }

    return false;
  };

  const shouldHighlightLine = (line, index) => {
    return isStartEndHighlighted(index) || isInlineHighlighted(line);
  };

  return jsx(Highlight, _extends({}, defaultProps, props, {
    code: children.trim(),
    language: lang,
    theme: undefined
  }), ({
    className,
    style,
    tokens,
    getLineProps,
    getTokenProps
  }) => {
    const tokensWithoutHighlightComments = findStartAndEndHighlights(tokens);
    return jsx(Themed.pre, {
      className: `${outerClassName} ${className}`,
      style: style
    }, tokensWithoutHighlightComments.map((line, i) => {
      const lineProps = getLineProps({
        line,
        key: i
      });

      if (shouldHighlightLine(line, i)) {
        lineProps.className = `${lineProps.className} highlight`;
      }

      return jsx("div", lineProps, line.map((token, key) => jsx("span", _extends({}, getTokenProps({
        token,
        key
      }), {
        sx: token.empty ? {
          display: 'inline-block'
        } : undefined
      }))));
    }));
  });
}

export default ThemeUIPrism;
