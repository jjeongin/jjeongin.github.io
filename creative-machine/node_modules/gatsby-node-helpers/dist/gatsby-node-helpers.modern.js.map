{"version":3,"file":"gatsby-node-helpers.modern.js","sources":["../src/index.ts"],"sourcesContent":["import * as gatsby from 'gatsby'\nimport * as pc from 'pascal-case'\nimport * as cc from 'camel-case'\n\n/**\n * Converts a collection of strings to a single Pascal cased string.\n *\n * @param parts Strings to convert into a single Pascal cased string.\n *\n * @return Pascal cased string version of `parts`.\n */\nconst pascalCase = (...parts: (string | null | undefined)[]): string =>\n  pc.pascalCase(parts.filter((p) => p != null).join(' '), {\n    transform: pc.pascalCaseTransformMerge,\n  })\n\n/**\n * Converts a collection of strings to a single camel cased string.\n *\n * @param parts Strings to convert into a single camel cased string.\n *\n * @return Camel cased string version of `parts`.\n */\nconst camelCase = (...parts: (string | null | undefined)[]): string =>\n  cc.camelCase(parts.filter((p) => p != null).join(' '), {\n    transform: cc.camelCaseTransformMerge,\n  })\n\n/**\n * Casts a value to an array. If the input is an array, the input is returned as\n * is. Otherwise, the input is returned as a single element array with the input\n * as its only value.\n *\n * @param input Input that will be casted to an array.\n *\n * @return `input` that is guaranteed to be an array.\n */\nconst castArray = <T>(input: T | T[]): T[] =>\n  Array.isArray(input) ? input : [input]\n\n/**\n * Reserved fields for Gatsby nodes.\n */\nconst RESERVED_GATSBY_NODE_FIELDS = [\n  'id',\n  'internal',\n  'fields',\n  'parent',\n  'children',\n] as const\n\ninterface CreateNodeHelpersParams {\n  /** Prefix for all nodes. Used as a namespace for node type names. */\n  typePrefix: string\n  /**\n   * Prefix for field names. Used as a namespace for fields that conflict with\n   * Gatsby's reserved field names.\n   * */\n  fieldPrefix?: string\n  /** Gatsby's `createNodeId` helper. */\n  createNodeId: gatsby.SourceNodesArgs['createNodeId']\n  /** Gatsby's `createContentDigest` helper. */\n  createContentDigest: gatsby.SourceNodesArgs['createContentDigest']\n}\n\n/**\n * A value that can be converted to a string using `toString()`.\n */\nexport interface Stringable {\n  toString(): string\n}\n\n/**\n * A record that can be globally identified using its `id` field.\n */\nexport interface IdentifiableRecord {\n  id: Stringable\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any\n}\n\n/**\n * Gatsby node helper functions to aid node creation.\n */\nexport interface NodeHelpers {\n  /**\n   * Creates a namespaced type name in Pascal case. Nodes created using a\n   * `createNodeFactory` function will automatically be namespaced using this\n   * function.\n   *\n   * @param parts Parts of the type name. If more than one string is provided,\n   * they will be concatenated in Pascal case.\n   *\n   * @return Namespaced type name.\n   */\n  createTypeName: (parts: string | string[]) => string\n\n  /**\n   * Creates a namespaced field name in camel case. Nodes created using a\n   * `createNodeFactory` function will automatically have namespaced fields\n   * using this function ONLY if the name conflicts with Gatsby's reserved\n   * fields.\n   *\n   * @param parts Parts of the field name. If more than one string is provided,\n   * they will be concatenated in camel case.\n   *\n   * @return Namespaced field name.\n   */\n  createFieldName: (parts: string | string[]) => string\n\n  /**\n   * Creates a deterministic node ID based on the `typePrefix` option provided\n   * to `createNodeHelpers` and the provided `parts` argument. Providing the\n   * same `parts` will always return the same result.\n   *\n   * @param parts Strings to globally identify a node within the domain of the\n   * node helpers.\n   *\n   * @return Node ID based on the provided `parts`.\n   */\n  createNodeId: (parts: string | string[]) => string\n\n  /**\n   * Creates a function that will convert an identifiable record (one that has\n   * an `id` field) to a valid input for Gatsby's `createNode` action.\n   *\n   * @param nameParts Parts of the type name for the resulting factory. All\n   * records called with the resulting function will have a type name based on\n   * this parameter.\n   *\n   * @param options Options to control the resulting function's output.\n   *\n   * @return A function that converts an identifiable record to a valid input\n   * for Gatsby's `createNode` action.\n   */\n  createNodeFactory: (\n    nameParts: string | string[],\n    options?: CreateNodeFactoryOptions,\n  ) => (node: IdentifiableRecord) => gatsby.NodeInput\n}\n\n/**\n * Options for a node factory.\n */\ntype CreateNodeFactoryOptions = {\n  /**\n   * Determines if the node's `id` field is unique within all nodes created with\n   * this collection of node helpers.\n   *\n   * If `false`, the ID will be namespaced with the node's type and the\n   * `typePrefix` value.\n   *\n   * If `true`, the ID will not be namespaced with the node's type, but will still\n   * be namespaced with the `typePrefix` value.\n   *\n   * @defaultValue `false`\n   */\n  idIsGloballyUnique?: boolean\n}\n\n/**\n * Creates Gatsby node helper functions to aid node creation.\n */\nexport const createNodeHelpers = ({\n  typePrefix,\n  fieldPrefix = typePrefix,\n  createNodeId: gatsbyCreateNodeId,\n  createContentDigest: gatsbyCreateContentDigest,\n}: CreateNodeHelpersParams): NodeHelpers => {\n  const createTypeName = (nameParts: string | string[]): string =>\n    pascalCase(typePrefix, ...castArray(nameParts))\n\n  const createFieldName = (nameParts: string | string[]): string =>\n    camelCase(fieldPrefix, ...castArray(nameParts))\n\n  const createNodeId = (nameParts: string | string[]): string =>\n    gatsbyCreateNodeId(\n      [typePrefix, ...castArray(nameParts)].filter((p) => p != null).join(' '),\n    )\n\n  const createNodeFactory = (\n    nameParts: string | string[],\n    { idIsGloballyUnique = false }: CreateNodeFactoryOptions = {},\n  ) => (node: IdentifiableRecord): gatsby.NodeInput => {\n    const id = idIsGloballyUnique\n      ? createNodeId(node.id.toString())\n      : createNodeId([...castArray(nameParts), node.id.toString()])\n\n    const res = {\n      ...node,\n      id,\n      internal: {\n        type: createTypeName(nameParts),\n        contentDigest: gatsbyCreateContentDigest(node),\n      },\n    } as gatsby.NodeInput\n\n    for (const reservedField of RESERVED_GATSBY_NODE_FIELDS) {\n      if (reservedField in node) {\n        res[createFieldName(reservedField)] = node[reservedField]\n      }\n    }\n\n    return res\n  }\n\n  return {\n    createTypeName,\n    createFieldName,\n    createNodeId,\n    createNodeFactory,\n  }\n}\n"],"names":["castArray","input","Array","isArray","RESERVED_GATSBY_NODE_FIELDS","createNodeHelpers","typePrefix","fieldPrefix","createNodeId","gatsbyCreateNodeId","createContentDigest","gatsbyCreateContentDigest","createTypeName","nameParts","parts","pc","filter","p","join","transform","pascalCase","createFieldName","cc","camelCase","createNodeFactory","idIsGloballyUnique","node","id","toString","res","internal","type","contentDigest","reservedField"],"mappings":"0VAWA,MA0BMA,EAAgBC,GACpBC,MAAMC,QAAQF,GAASA,EAAQ,CAACA,GAK5BG,EAA8B,CAClC,KACA,WACA,SACA,SACA,YAmHWC,EAAoB,EAC/BC,WAAAA,EACAC,YAAAA,EAAcD,EACdE,aAAcC,EACdC,oBAAqBC,MAErB,MAAMC,EAAkBC,GA9JP,KAAIC,IACrBC,EAAcD,EAAME,OAAQC,GAAW,MAALA,GAAWC,KAAK,KAAM,CACtDC,UAAWJ,IA6JXK,CAAWd,KAAeN,EAAUa,IAEhCQ,EAAmBR,GArJT,KAAIC,IACpBQ,EAAaR,EAAME,OAAQC,GAAW,MAALA,GAAWC,KAAK,KAAM,CACrDC,UAAWG,IAoJXC,CAAUhB,KAAgBP,EAAUa,IAEhCL,EAAgBK,GACpBJ,EACE,CAACH,KAAeN,EAAUa,IAAYG,OAAQC,GAAW,MAALA,GAAWC,KAAK,MA6BxE,MAAO,CACLN,eAAAA,EACAS,gBAAAA,EACAb,aAAAA,EACAgB,kBA9BwB,CACxBX,GACEY,mBAAAA,GAAqB,GAAoC,KACvDC,IACJ,MAAMC,EACFnB,EADOiB,EACMC,EAAKC,GAAGC,WACR,IAAI5B,EAAUa,GAAYa,EAAKC,GAAGC,aAE7CC,OACDH,GACHC,GAAAA,EACAG,SAAU,CACRC,KAAMnB,EAAeC,GACrBmB,cAAerB,EAA0Be,MAI7C,IAAK,MAAMO,KAAiB7B,EACtB6B,KAAiBP,IACnBG,EAAIR,EAAgBY,IAAkBP,EAAKO,IAI/C,OAAOJ"}